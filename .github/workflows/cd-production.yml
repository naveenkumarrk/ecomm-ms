name: CD Main (Production Deploy)

on:
	push:
		branches: [main]

jobs:
	detect-changes:
		runs-on: ubuntu-latest
		outputs:
			services: ${{ steps.changes.outputs.services }}
			has-changes: ${{ steps.changes.outputs.has-changes }}
		steps:
			- uses: actions/checkout@v4
				with:
					fetch-depth: 2

			- name: Detect Changed Services
				id: changes
				run: |
					# Get changed files from last commit
					CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
					
					# Initialize services array
					SERVICES_ARRAY=()
					HAS_CHANGES="false"
					
					# Check each service directory
					for SERVICE in auth-worker cart-worker fulfillment-worker gateway-worker inventory-worker order-worker payment-worker product-worker; do
						if echo "$CHANGED_FILES" | grep -q "^$SERVICE/"; then
							SERVICES_ARRAY+=("$SERVICE")
							HAS_CHANGES="true"
						fi
					done
					
					# Check root changes (affects all services)
					if echo "$CHANGED_FILES" | grep -qE "^(package\.json|knip\.json|\.github/|\.prettierrc)"; then
						HAS_CHANGES="true"
						SERVICES_ARRAY=("auth-worker" "cart-worker" "fulfillment-worker" "gateway-worker" "inventory-worker" "order-worker" "payment-worker" "product-worker")
					fi
					
					# Convert array to JSON and space-separated string
					SERVICES_JSON=$(printf '%s\n' "${SERVICES_ARRAY[@]}" | jq -R . | jq -s .)
					SERVICES_STRING=$(IFS=' '; echo "${SERVICES_ARRAY[*]}")
					
					echo "services=$SERVICES_STRING" >> $GITHUB_OUTPUT
					echo "services-json=$SERVICES_JSON" >> $GITHUB_OUTPUT
					echo "has-changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
					
					if [ "$HAS_CHANGES" = "true" ]; then
						echo "Changed services: $SERVICES_STRING"
					else
						echo "No service changes detected"
					fi

	deploy-production:
		runs-on: ubuntu-latest
		needs: detect-changes
		if: needs.detect-changes.outputs.has-changes == 'true'
		environment: production
		strategy:
			fail-fast: false
			matrix:
				service: ${{ fromJson(needs.detect-changes.outputs.services-json) }}
		outputs:
			deployment-ids: ${{ steps.deploy-all.outputs.deployment-ids }}
		steps:
			- uses: actions/checkout@v4

			- name: Install jq
				run: sudo apt-get update && sudo apt-get install -y jq

			- uses: actions/setup-node@v4
				with:
					node-version: 20
					cache: 'npm'
					cache-dependency-path: ${{ matrix.service }}/package-lock.json

			- name: Install dependencies
				working-directory: ${{ matrix.service }}
				run: npm ci

			- name: Deploy to Production Worker
				id: deploy
				working-directory: ${{ matrix.service }}
				env:
					CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
					CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
				run: |
					# Deploy and capture output
					OUTPUT=$(npx wrangler deploy 2>&1 || true)
					echo "$OUTPUT"
					
					# Extract deployment ID if available
					DEPLOYMENT_ID=$(echo "$OUTPUT" | grep -oP 'deployment-id: \K[a-f0-9-]+' || echo "")
					
					if [ -z "$DEPLOYMENT_ID" ]; then
						DEPLOYMENT_ID=$(date +%s)-${{ matrix.service }}
					fi
					
					echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
					echo "service=${{ matrix.service }}" >> $GITHUB_OUTPUT
					
					# Store last known good deployment
					mkdir -p .deployments
					echo "$DEPLOYMENT_ID" > .deployments/${{ matrix.service }}-production-last-good.txt
					
					# Check if deployment was successful
					if echo "$OUTPUT" | grep -qE "(deployed|successfully|Deployed)"; then
						echo "âœ… Deployment successful for ${{ matrix.service }}"
						echo "deployment-status=success" >> $GITHUB_OUTPUT
					else
						echo "::error::Deployment failed for ${{ matrix.service }}"
						echo "deployment-status=failure" >> $GITHUB_OUTPUT
						exit 1
					fi

			- name: Store Last Known Good Deployment
				if: success()
				uses: actions/upload-artifact@v4
				with:
					name: last-good-production-${{ matrix.service }}
					path: .deployments/${{ matrix.service }}-production-last-good.txt
					retention-days: 90

	integration-tests:
		runs-on: ubuntu-latest
		needs: deploy-production
		if: always() && needs.deploy-production.result != 'cancelled'
		environment: production
		strategy:
			fail-fast: false
			matrix:
				service: ${{ fromJson(needs.detect-changes.outputs.services-json) }}
		steps:
			- uses: actions/checkout@v4

			- name: Install jq
				run: sudo apt-get update && sudo apt-get install -y jq

			- uses: actions/setup-node@v4
				with:
					node-version: 20
					cache: 'npm'
					cache-dependency-path: ${{ matrix.service }}/package-lock.json

			- name: Install dependencies
				working-directory: ${{ matrix.service }}
				run: npm ci

			- name: Run Integration Tests
				working-directory: ${{ matrix.service }}
				env:
					PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
				run: npm run test:integration || true

	notify-production-success:
		runs-on: ubuntu-latest
		needs: [deploy-production, integration-tests]
		if: success() && needs.deploy-production.result == 'success'
		steps:
			- name: Send Slack Success Notification
				uses: slackapi/slack-github-action@v1
				with:
					webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
					payload: |
						{
							"text": "ðŸš€ Production Deployment Successful",
							"blocks": [
								{
									"type": "header",
									"text": {
										"type": "plain_text",
										"text": "ðŸš€ Production Deployment Successful"
									}
								},
								{
									"type": "section",
									"fields": [
										{
											"type": "mrkdwn",
											"text": "*Branch:*\nmain"
										},
										{
											"type": "mrkdwn",
											"text": "*Commit:*\n<${{ github.event.head_commit.url }}|${{ github.sha }}>"
										},
										{
											"type": "mrkdwn",
											"text": "*Author:*\n${{ github.event.head_commit.author.name }}"
										},
										{
											"type": "mrkdwn",
											"text": "*Services:*\n${{ needs.detect-changes.outputs.services }}"
										}
									]
								}
							]
						}

	rollback-production:
		runs-on: ubuntu-latest
		needs: [deploy-production, integration-tests]
		if: failure() && needs.deploy-production.result == 'success'
		environment: production
		strategy:
			fail-fast: false
			matrix:
				service: ${{ fromJson(needs.detect-changes.outputs.services-json) }}
		steps:
			- uses: actions/checkout@v4

			- name: Install jq
				run: sudo apt-get update && sudo apt-get install -y jq

			- uses: actions/setup-node@v4
				with:
					node-version: 20
					cache: 'npm'
					cache-dependency-path: ${{ matrix.service }}/package-lock.json

			- name: Install dependencies
				working-directory: ${{ matrix.service }}
				run: npm ci

			- name: Download Last Known Good Deployment
				uses: actions/download-artifact@v4
				with:
					name: last-good-production-${{ matrix.service }}
					continue-on-error: true

			- name: Rollback to Last Known Good Version
				working-directory: ${{ matrix.service }}
				env:
					CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
					CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
				run: |
					if [ -f .deployments/${{ matrix.service }}-production-last-good.txt ]; then
						LAST_GOOD=$(cat .deployments/${{ matrix.service }}-production-last-good.txt)
						echo "Rolling back ${{ matrix.service }} to: $LAST_GOOD"
						npx wrangler rollback || npx wrangler rollback --deployment-id "$LAST_GOOD" || echo "Rollback attempted"
					else
						echo "No last known good deployment found, attempting standard rollback"
						npx wrangler rollback || echo "Rollback attempted"
					fi

			- name: Send Slack Rollback Notification
				uses: slackapi/slack-github-action@v1
				with:
					webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
					payload: |
						{
							"text": "ðŸš¨ Production Deployment Failed - Rolled Back",
							"blocks": [
								{
									"type": "header",
									"text": {
										"type": "plain_text",
										"text": "ðŸš¨ Production Deployment Failed - Rolled Back"
									}
								},
								{
									"type": "section",
									"fields": [
										{
											"type": "mrkdwn",
											"text": "*Service:*\n${{ matrix.service }}"
										},
										{
											"type": "mrkdwn",
											"text": "*Branch:*\nmain"
										},
										{
											"type": "mrkdwn",
											"text": "*Commit:*\n<${{ github.event.head_commit.url }}|${{ github.sha }}>"
										},
										{
											"type": "mrkdwn",
											"text": "*Action:*\nRolled back to previous version"
										}
									]
								}
							]
						}

